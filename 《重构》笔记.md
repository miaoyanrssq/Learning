#《重构》 笔记

定义：
> 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

## 为何重构

* 重构改进软件设计
* 重构使软件更容易理解
* 重构帮助找到bug
* 重构提高编程速度

## 何时重构

* 三次法则--事不过三，三则重构 

第一次做某件事时只管去做，第二次做类似的事会产生反感，但无论如何还是可以去做，第三次再做类似的事情，你就应该重构了

* 添加功能时重构
* 修补错误时重构
* 复审代码时重构

## 坏代码的味道
* 重复代码
* 过长函数  

分解函数原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中，并以其用途（而非实现手法）命名。  

* 过大的类
* 过长的参数列
* 发散式变化--一个类受多种变化的影响
* 霰弹式修改--一种变化引发多个类相应修改
* 依恋情结
* 数据泥团
* 基本类型偏执
* switch惊悚现身
* 平行继承体系
* 冗赘类
* 夸夸其谈未来性
* 令人迷惑的暂时字段
* 过度耦合的消息链
* 中间人--过度委托
* 狎昵关系
* 异曲同工的类
* 不完美的类库
* Data Class （纯稚的数据类）
* 被拒绝的遗赠
* 过多的注释

## 重构方法列表

### 1、Extract Method（提炼函数）
将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。

**动机**  
如果每个函数的粒度都很小，那么复用的机会就越大，其次，这会使高层函数读起来就像一系列注释。

### 2、Inline Method（内联函数）

如果一个函数的本体和名称同样清楚易懂，那么，在函数调用点插入函数本体，然后移除该函数。  

### 3、Inline Temp（内联临时变量）
将所有对该变量的引用动作，替换为它赋值的那个表达式自身。

### 4、Replace Temp with Query（以查询取代临时变量）
你的程序以一个临时变量保存某以表达式的运算结构，将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用，此后，新函数就可以被其他函数使用。

### 5、Introduce Explaining Variable（引入解释性变量）
你有一个复杂的表达式，将该复杂表达式（或其中的一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。

### 6、Split Temporary Variable（分解临时变量）
你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。

### 7、Remove Assignments to Parameters（移除对参数的赋值）

### 8、Replace Method with Method Object（以函数对象取代函数）
你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method。将这个函数放进一个单独的对象中，如此一来局部变量就成了对象内的字段，然后你就可以在同一个对象中将这个大型函数分解为多个小型函数。

### 9、Substitute Algorithm（替换算法）
你想要把某个算法替换为另一个更清晰的算法。将函数本体替换为另一个算法。

###10、Move Method（搬移函数）
你的程序中，有个函数与其所驻类之外的另一个类进行更多的交流：调用后者或被后者调用。在该函数最常引用的类中建立一个有着类似行为的新函数，将旧函数变成一个单纯的委托函数，或将旧函数完全移除。

### 11、Move Field（搬移字段）
你的程序中，某个字段被另一个类更多的用到。在目标类新建一个字段，修改源字段的所有用户，另它们该用新字段。

### 12、Extract Class（提炼类）
某个类做了应该由两个类做的事。建立一个新类，将相关的字段和函数从旧类搬移到新类。

### 13、Inline Class（将类内联化）
某个类没有做太多事情。将这个类的所有特性搬移到另一个类中，然后移除原类。

### 14、Hide Delegate（隐藏“委托关系”）
客户通过一个委托类来调用另一个对象。在服务类上建立客户所需的所有函数，用以隐藏委托关系。

### 15、Remove Middle Man（移除中间人）
和14相反，某个类做了过多的简单委托动作，将客户直接调用受拖类。

### 16、Introduce Foreign Method（引入外加函数）
你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。

### 17、Introduce Local Extension（引入本地扩展）
你需要为服务类提供一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数，让这个扩展类成为源类的子类或者包装类。

### 18、Self Encapsulate Field（自封装字段）
你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。

### 19、Replace Data Value with Object（以对象取代数据值）
你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变成对象。  

### 20、Change Value to Reference（将值对象改为引用对象）
你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。

### 21、Change Reference to Value（将引用对象改为值对象）
你有一个引用对象，很小且不可变，而且不易管理。将它变成一个值对象。

### 22、Replace Array with Object（以对象取代数组）
你有一个数组，其中的元素各自代表不同的东西。以对象替换数组，对于数组中的每个元素，以一个字段来表示。

### 23、Duplicate Observed Data（复制“被监视数据”）
你有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。

### 24、Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）
两个类都需要使用对方特性，但其间只有一条单向连接。添加一个反向指针，并使修改函数能同时更新两条连接。

### 25、Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）
两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。

### 26、Replace Magic Number with Symbolic Constant(以字面常量取代魔法值)
你有一个字面数值，带有特别含义。创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。

### 27、Encapsulate Field（封装字段）
你的类中存在一个public 字段。将它声明为private，并提供相应的访问函数。

### 28、Encapsulate Collection（封装集合）
有一个函数返回一个集合。让这个函数范围该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。

### 29、 Decompose Conditional（分解条件表达式）
你有一个复杂的条件（if-then-else）语句。从if、then、else三个段落中分别提炼出独立的函数。

### 30、Consolidate Conditional Expression（合并条件表达式）
你有一系列条件测试，都得到相同的结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼成一个独立的函数。

### 31、Consolidate Duplicate Conditional Fragments（合并重复的条件片段）
在条件表达式的每个分支上有着相同的一段代码。将这段重复代码搬移到条件表达式之外。

### 32、Remove Control Flag（移除控制标记）
在一些列布尔表达式中，某个变量带有“控制标记”的作用。以break语句或return 语句取代控制标记。
 
### 33、Replace Conditional with Polymorphism（以多态取代条件表达式）
你手上有一个条件表达式，它根据对象类型的不同而选择不同的行为。将这个条件表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。

### 34、Rename Method（函数改名）
函数的名称为能揭示函数的用途。修改函数名称。
 
### 35、Add Parameter（添加参数）
某个函数需要从调用端得到更多的 信息。为此函数添加一个对象参数，让该对象带进函数所需信息。

### 36、Separate Query from Modifier（将查询函数和修改函数分离）
某个函数即返回对象状态值，又修改对象状态。建立两个不同的函数，分别负责查询和修改。

### 37、Hide Method（隐藏函数）
有一个函数，从来没有被其他类用到。将函数修改为private。

### 38、以工厂函数取代构造函数
你希望在创建对象时不仅仅是做简单的创建动作。将构造函数替换为工厂函数。

### 39、以异常取代错误码
某个函数返回一个特定的代码，用以表示某种错误。改用异常。

### 40、以测试取代异常
面对一个调用者可以预先检查的条件，你抛出了一个异常。修改调用者，使它在调用函数之前先做检查。

### 41、字段上移
两个子类拥有相同的字段。将该字段移至超类。

### 42、函数上移
有些函数，在各个子类中产生完全相同的结果。将该函数移至超类。

### 43、构造函数上移

### 44、字段、函数、构造函数下移

### 45、提炼子类/超类/接口

### 46、塑造模版函数

### 47、以委托取代继承
某个子类只使用了超类接口中的一部分，或是根本不需要继承而来的数据。在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。

### 48、以继承取代委托

### 49、梳理并分解继承体系
某个继承体系同时承担两项责任。建立两个继承体系，并通过委托关系让一个调用另一个。


