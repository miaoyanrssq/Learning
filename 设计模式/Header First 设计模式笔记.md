#HeadFirst 设计模式笔记
> 本文为《HeadFirst 设计模式》的阅读笔记，如有不理解的地方，请参考原书

##设计原则

### 『策略模式』 定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
* **1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起**  
把会变化的部分取出并封装起来，以便以后可以轻易地扩充此部分，而不影响不需要变化的其他部分  
* **2、针对接口编程，而不是人针对实现编程**  
「针对接口编程」真正的意思是「针对超类型（supertype）编程」。  
这里所谓的「接口」有多个含意，接口是一个「概念」，
也是一种Java的interface构造。你可以在不涉及Java 
interface的情况下，「针对接口编程」，关键就在多态。
利用多态，程序可以针对超类型编程，执行时会根据实际状
况执行到真正的行为，不会被绑死在超类型的行为上。「针
对超类型编程」这句话，可以更明确地说成「变量的声明类
型，应该是超类型，通常是一个抽象类或者是一个接口，如
此，只要是具体实现此超类型的类所产生的对象，都可以指
定给这个变量；这也意味着，声明类时，不用理会以后执行
时的真正对象类型！」  
* **3、多用组合，少用继承**  
使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以『在运行时动态地改变行为』，只要组合的行为对象，符合正确的接口标准即可  

### 『观察者模式』 在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，，并自动更新
* **4、为了交互对象之间的松耦合设计而努力**  
松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。

### 『装饰者模式』动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案  
* **5、类应该对扩展开放，对修改关闭**

### 『工厂方法模式』定义了一个常见对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

![] (image/factroy.png)

* **6、依赖倒置原则：要依赖抽象，不要依赖具体类**

首先，这个原则听起来很像“针对接口编程，不针对实现编程”，然而这里更强调“抽象”。这个原则说明，不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。  
下面几个知道方针，能帮助避免在OO设计中违反依赖倒置原则：  
1、变量不可以持有具体类的引用。
2、不要让类派生自具体类   
3、不要覆盖基类中已实现的方法。
并不是完全遵循以上方针，不然我们就写不出程序了，只是要我们在思考设计的时候尽量达到这个原则。  

### 『抽象工厂模式』提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

抽象工厂的方法经常以工厂方法的方式实现，抽象工厂的任务是定义一个负责创建一组产品的接口，这个接口内的每个方法都负责创建一个具体的产品，同时我们利用实现抽象工厂的子类来提供这些具体的做法，所以，在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。  

### 『单例模式』确保一个类只有一个实例，并提供一个全局访问点。

```
private class Singleton{
	private volatile static Singleton uniqueInstance;
	private Singleton(){}
	
	pulbic static Singleton getInstance(){
		if(uniqueInstance == null){
			synchronized(Singleton.class){
				if(uniqueInstance == null){
					uniqueInstance = new Singleton();
				}
			}
		}
		return uniqueInstance;
	}
}
```

双层检查加锁，在getInstance（）中减少使用同步，确保频繁使用同步带来的性能问题  
**volatile**关键词确保：当uniqueInstance变量呗初始化成Singleton实例时，多个线程正确的处理unniqueInstance变量。

### 『命令模式』将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

### 『适配器模式』将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。  

### 『外观模式』提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。  

* **7、最少知识原则：只和你的密友谈话**   
这个原则希望我们在设计中，不要让太多的类耦合在一起，面的修改系统中的一部分，会影响到其他部分。  
这个原则提供了一些方针：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法：  
1、该对象本身。  
2、被当作方法的参数而传递进来的对象。  
3、此方法所穿件或者实例化的任何对象。  
4、对象的任何组件。  

这是一个汽车类，展示调用方法的各种做法，同时还能够遵守最少知识原则：
![] (image/exterior.png)

### 『模版方法模式』在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

* **8、好莱坞原则：别调用我们，我们会调用你**  
我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组件对待低层组件的方式是“别调用我们，我们会调用你”。

  
### 『迭代器模式』提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

* **9、一个类应该只有一个引起变化的原因**  

### 『组合模式』允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。  


### 『状态模式』允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

### 『代理模式』为另一个对象提供一个替身或者占位符以控制对这个对象的访问。  



