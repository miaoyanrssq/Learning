#æœºå™¨å­¦ä¹ Tensorflowï¼ˆ3ï¼‰-TenserflowåŸºç¡€æ„æ¶

##å¤„ç†ç»“æ„

###è®¡ç®—å›¾çº¸
Tensorflow é¦–å…ˆè¦å®šä¹‰ç¥ç»ç½‘ç»œçš„ç»“æ„, ç„¶åå†æŠŠæ•°æ®æ”¾å…¥ç»“æ„å½“ä¸­å»è¿ç®—å’Œ training.

![] (image/tf14.gif)

å› ä¸ºTensorFlowæ˜¯é‡‡ç”¨æ•°æ®æµå›¾ï¼ˆdataã€€flowã€€graphsï¼‰æ¥è®¡ç®—, æ‰€ä»¥é¦–å…ˆæˆ‘ä»¬å¾—åˆ›å»ºä¸€ä¸ªæ•°æ®æµæµå›¾, ç„¶åå†å°†æˆ‘ä»¬çš„æ•°æ®ï¼ˆæ•°æ®ä»¥å¼ é‡(tensor)çš„å½¢å¼å­˜åœ¨ï¼‰æ”¾åœ¨æ•°æ®æµå›¾ä¸­è®¡ç®—. èŠ‚ç‚¹ï¼ˆNodesï¼‰åœ¨å›¾ä¸­è¡¨ç¤ºæ•°å­¦æ“ä½œ,å›¾ä¸­çš„çº¿ï¼ˆedgesï¼‰åˆ™è¡¨ç¤ºåœ¨èŠ‚ç‚¹é—´ç›¸äº’è”ç³»çš„å¤šç»´æ•°æ®æ•°ç»„, å³å¼ é‡ï¼ˆtensor). è®­ç»ƒæ¨¡å‹æ—¶tensorä¼šä¸æ–­çš„ä»æ•°æ®æµå›¾ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹flowåˆ°å¦ä¸€èŠ‚ç‚¹, è¿™å°±æ˜¯TensorFlowåå­—çš„ç”±æ¥.


###Tensor å¼ é‡æ„ä¹‰ 

**å¼ é‡ï¼ˆTensor)**:

* å¼ é‡æœ‰å¤šç§. é›¶é˜¶å¼ é‡ä¸º çº¯é‡æˆ–æ ‡é‡ (scalar) ä¹Ÿå°±æ˜¯ä¸€ä¸ªæ•°å€¼. æ¯”å¦‚ [1]
* ä¸€é˜¶å¼ é‡ä¸º å‘é‡ (vector), æ¯”å¦‚ ä¸€ç»´çš„ [1, 2, 3]
* äºŒé˜¶å¼ é‡ä¸º çŸ©é˜µ (matrix), æ¯”å¦‚ äºŒç»´çš„ [[1, 2, 3],[4, 5, 6],[7, 8, 9]]
* ä»¥æ­¤ç±»æ¨, è¿˜æœ‰ ä¸‰é˜¶ ä¸‰ç»´çš„ â€¦


## ä¸¾ä¸ªğŸŒ°

Tensorflow æ˜¯éå¸¸é‡è§†ç»“æ„çš„, æˆ‘ä»¬å¾—å»ºç«‹å¥½äº†ç¥ç»ç½‘ç»œçš„ç»“æ„, æ‰èƒ½å°†æ•°å­—æ”¾è¿›å», è¿è¡Œè¿™ä¸ªç»“æ„.

è¿™ä¸ªä¾‹å­ç®€å•çš„é˜è¿°äº† tensorflow å½“ä¸­å¦‚ä½•ç”¨ä»£ç æ¥è¿è¡Œæˆ‘ä»¬æ­å»ºçš„ç»“æ„.

### åˆ›å»ºæ•°æ®

é¦–å…ˆ, æˆ‘ä»¬è¿™æ¬¡éœ€è¦åŠ è½½ tensorflow å’Œ numpy ä¸¤ä¸ªæ¨¡å—, å¹¶ä¸”ä½¿ç”¨ numpy æ¥åˆ›å»ºæˆ‘ä»¬çš„æ•°æ®.

```
import tensorflow as tf
import numpy as np

#create data
x_data = np.random.rand(100).astype(np.float32)
y_data = x_data*0.1 + 0.3

```

æ¥ç€, æˆ‘ä»¬ç”¨ `tf.Variable` æ¥åˆ›å»ºæè¿° `y` çš„å‚æ•°. æˆ‘ä»¬å¯ä»¥æŠŠ `y_data = x_data*0.1 + 0.3 `æƒ³è±¡æˆ `y=Weights * x + biases`, ç„¶åç¥ç»ç½‘ç»œä¹Ÿå°±æ˜¯å­¦ç€æŠŠ `Weights` å˜æˆ 0.1, `biases` å˜æˆ 0.3.

### åˆ›å»ºæ¨¡å‹

```
Weights = tf.Variable(tf.random_uniform([1], -1.0, 1.0))
biases = tf.Variable(tf.zeros([1]))

y = Weights*x_data + biases
```

###è®¡ç®—è¯¯å·®

æ¥ç€å°±æ˜¯è®¡ç®—`y`å’Œ`y_data`çš„è¯¯å·®

```
loss = tf.reduce_mean(tf.square(y-y_data))
```

### ä¼ æ’­è¯¯å·®

åå‘ä¼ é€’è¯¯å·®çš„å·¥ä½œå°±äº¤ç»™`optimizer`äº†ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„è¯¯å·®ä¼ é€’æ–¹æ³•æ˜¯æ¢¯åº¦ä¸‹é™æ³•ï¼š`Grandient Desent`ç„¶åæˆ‘ä»¬ä½¿ç”¨`optimizer`æ¥è¿›è¡Œå‚æ•°æ›´æ–°ã€‚

```
optimizer = tf.train.GradientDescentOptimizer(0.5)
train = optimizer.minimize(loss)
```

### è®­ç»ƒ

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯å»ºç«‹äº†ç¥ç»ç½‘ç»œçš„ç»“æ„ï¼Œè¿˜æ²¡æœ‰ä½¿ç”¨è¿™ä¸ªç»“æ„ï¼Œåœ¨ä½¿ç”¨è¿™ä¸ªç»“æ„ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»å…ˆåˆå§‹åŒ–æ‰€æœ‰ä¹‹å‰å®šä¹‰çš„`Variable`ï¼Œæ‰€ä»¥è¿™ä¸€æ­¥æ˜¯å¾ˆé‡è¦çš„ï¼

```
# init = tf.initialize_all_variables() #tfé©¬ä¸Šå°±è¦åºŸå¼ƒè¿™ç§å†™æ³•
init = tf.global_variables_initializer() #æ›¿æ¢æˆè¿™æ ·å°±å¥½
```
æ¥ç€,æˆ‘ä»¬å†åˆ›å»ºä¼šè¯ `Session.`  æˆ‘ä»¬ç”¨ `Session `æ¥æ‰§è¡Œ `init` åˆå§‹åŒ–æ­¥éª¤. å¹¶ä¸”, ç”¨ `Session` æ¥ `run` æ¯ä¸€æ¬¡ training çš„æ•°æ®. é€æ­¥æå‡ç¥ç»ç½‘ç»œçš„é¢„æµ‹å‡†ç¡®æ€§.

```
sess = tf.Session()
sess.run(init)          # Very important

for step in range(201):
    sess.run(train)
    if step % 20 == 0:
        print(step, sess.run(Weights), sess.run(biases))
```

ğŸŒ°end===================================

##Session ä¼šè¯æ§åˆ¶

`Session` æ˜¯ Tensorflow ä¸ºäº†æ§åˆ¶,å’Œè¾“å‡ºæ–‡ä»¶çš„æ‰§è¡Œçš„è¯­å¥. è¿è¡Œ `session.run()` å¯ä»¥è·å¾—ä½ è¦å¾—çŸ¥çš„è¿ç®—ç»“æœ, æˆ–è€…æ˜¯ä½ æ‰€è¦è¿ç®—çš„éƒ¨åˆ†.

é¦–å…ˆï¼Œæˆ‘ä»¬è¿™æ¬¡éœ€è¦åŠ è½½ Tensorflow ï¼Œç„¶åå»ºç«‹ä¸¤ä¸ª `matrix` ,è¾“å‡ºä¸¤ä¸ª` matrix `çŸ©é˜µç›¸ä¹˜çš„ç»“æœã€‚

```
import tensorflow as tf

# create two matrixes

matrix1 = tf.constant([[3,3]])
matrix2 = tf.constant([[2],
                       [2]])
product = tf.matmul(matrix1,matrix2)
```

å› ä¸º product ä¸æ˜¯ç›´æ¥è®¡ç®—çš„æ­¥éª¤, æ‰€ä»¥æˆ‘ä»¬ä¼šè¦ä½¿ç”¨ Session æ¥æ¿€æ´» product å¹¶å¾—åˆ°è®¡ç®—ç»“æœ. æœ‰ä¸¤ç§å½¢å¼ä½¿ç”¨ä¼šè¯æ§åˆ¶ Session ã€‚

```
# method 1
sess = tf.Session()
result = sess.run(product)
print(result)
sess.close()
# [[12]]

# method 2
with tf.Session() as sess:
    result2 = sess.run(product)
    print(result2)
# [[12]]
```

##Variableå˜é‡

åœ¨ Tensorflow ä¸­ï¼Œå®šä¹‰äº†æŸå­—ç¬¦ä¸²æ˜¯å˜é‡ï¼Œå®ƒæ‰æ˜¯å˜é‡ï¼Œè¿™ä¸€ç‚¹æ˜¯ä¸ Python æ‰€ä¸åŒçš„ã€‚

å®šä¹‰è¯­æ³•ï¼š `state = tf.Variable()`

```
import tensorflow as tf

state = tf.Variable(0, name='counter')

# å®šä¹‰å¸¸é‡ one
one = tf.constant(1)

# å®šä¹‰åŠ æ³•æ­¥éª¤ (æ³¨: æ­¤æ­¥å¹¶æ²¡æœ‰ç›´æ¥è®¡ç®—)
new_value = tf.add(state, one)

# å°† State æ›´æ–°æˆ new_value
update = tf.assign(state, new_value)
```

å¦‚æœä½ åœ¨ Tensorflow ä¸­è®¾å®šäº†å˜é‡ï¼Œé‚£ä¹ˆåˆå§‹åŒ–å˜é‡æ˜¯æœ€é‡è¦çš„ï¼ï¼æ‰€ä»¥å®šä¹‰äº†å˜é‡ä»¥å, ä¸€å®šè¦å®šä¹‰ `init = tf.initialize_all_variables()` .

åˆ°è¿™é‡Œå˜é‡è¿˜æ˜¯æ²¡æœ‰è¢«æ¿€æ´»ï¼Œéœ€è¦å†åœ¨ `sess `é‡Œ, `sess.run(init)` , æ¿€æ´» `init` è¿™ä¸€æ­¥.

```
# å¦‚æœå®šä¹‰ Variable, å°±ä¸€å®šè¦ initialize
# init = tf.initialize_all_variables() # tf é©¬ä¸Šå°±è¦åºŸå¼ƒè¿™ç§å†™æ³•
init = tf.global_variables_initializer()  # æ›¿æ¢æˆè¿™æ ·å°±å¥½
 
# ä½¿ç”¨ Session
with tf.Session() as sess:
    sess.run(init)
    for _ in range(3):
        sess.run(update)
        print(sess.run(state))
```

æ³¨æ„ï¼šç›´æ¥ `print(state)` ä¸èµ·ä½œç”¨ï¼ï¼

ä¸€å®šè¦æŠŠ `sess` çš„æŒ‡é’ˆæŒ‡å‘ `state` å†è¿›è¡Œ `print` æ‰èƒ½å¾—åˆ°æƒ³è¦çš„ç»“æœï¼

## Placeholderä¼ å…¥å€¼

placeholder æ˜¯ Tensorflow ä¸­çš„å ä½ç¬¦ï¼Œæš‚æ—¶å‚¨å­˜å˜é‡.

Tensorflow å¦‚æœæƒ³è¦ä»å¤–éƒ¨ä¼ å…¥data, é‚£å°±éœ€è¦ç”¨åˆ° tf.placeholder(), ç„¶åä»¥è¿™ç§å½¢å¼ä¼ è¾“æ•°æ® sess.run(***, feed_dict={input: **}).

ç¤ºä¾‹ï¼š

```
import tensorflow as tf

#åœ¨ Tensorflow ä¸­éœ€è¦å®šä¹‰ placeholder çš„ type ï¼Œä¸€èˆ¬ä¸º float32 å½¢å¼
input1 = tf.placeholder(tf.float32)
input2 = tf.placeholder(tf.float32)

# mul = multiply æ˜¯å°†input1å’Œinput2 åšä¹˜æ³•è¿ç®—ï¼Œå¹¶è¾“å‡ºä¸º output 
ouput = tf.multiply(input1, input2)
```

æ¥ä¸‹æ¥, ä¼ å€¼çš„å·¥ä½œäº¤ç»™äº† `sess.run()` , éœ€è¦ä¼ å…¥çš„å€¼æ”¾åœ¨äº†`feed_dict={}` å¹¶ä¸€ä¸€å¯¹åº”æ¯ä¸€ä¸ª `input`. `placeholder` ä¸ `feed_dict={}` æ˜¯ç»‘å®šåœ¨ä¸€èµ·å‡ºç°çš„ã€‚

```
with tf.Session() as sess:
    print(sess.run(ouput, feed_dict={input1: [7.], input2: [2.]}))
# [ 14.]
```

## æ¿€åŠ±å‡½æ•°

æ¿€åŠ±å‡½æ•°è¿è¡Œæ—¶æ¿€æ´»ç¥ç»ç½‘ç»œä¸­æŸä¸€éƒ¨åˆ†ç¥ç»å…ƒï¼Œå°†æ¿€æ´»ä¿¡æ¯å‘åä¼ å…¥ä¸‹ä¸€å±‚çš„ç¥ç»ç³»ç»Ÿã€‚æ¿€åŠ±å‡½æ•°çš„å®è´¨æ˜¯éçº¿æ€§æ–¹ç¨‹ã€‚ Tensorflow çš„ç¥ç»ç½‘ç»œ é‡Œé¢å¤„ç†è¾ƒä¸ºå¤æ‚çš„é—®é¢˜æ—¶éƒ½ä¼šéœ€è¦è¿ç”¨æ¿€åŠ±å‡½æ•° activation function

![] (image/tf15.png)

è¿™é‡Œçš„ AF å°±æ˜¯æŒ‡çš„æ¿€åŠ±å‡½æ•°. æ¿€åŠ±å‡½æ•°æ‹¿å‡ºè‡ªå·±æœ€æ“…é•¿çš„â€æ°å¼¯åˆ©å™¨â€, å¥—åœ¨äº†åŸå‡½æ•°ä¸Š ç”¨åŠ›ä¸€æ‰­, åŸæ¥çš„ Wx ç»“æœå°±è¢«æ‰­å¼¯äº†.

å…¶å®è¿™ä¸ª AF, æ°å¼¯åˆ©å™¨, ä¹Ÿä¸æ˜¯ä»€ä¹ˆè§¦ä¸å¯åŠçš„ä¸œè¥¿. å®ƒå…¶å®å°±æ˜¯å¦å¤–ä¸€ä¸ªéçº¿æ€§å‡½æ•°. æ¯”å¦‚è¯´relu, sigmoid, tanh. å°†è¿™äº›æ°å¼¯åˆ©å™¨åµŒå¥—åœ¨åŸæœ‰çš„ç»“æœä¹‹ä¸Š, å¼ºè¡ŒæŠŠåŸæœ‰çš„çº¿æ€§ç»“æœç»™æ‰­æ›²äº†. ä½¿å¾—è¾“å‡ºç»“æœ y ä¹Ÿæœ‰äº†éçº¿æ€§çš„ç‰¹å¾. ä¸¾ä¸ªä¾‹å­, æ¯”å¦‚æˆ‘ä½¿ç”¨äº† relu è¿™ä¸ªæ°å¼¯åˆ©å™¨, å¦‚æœæ­¤æ—¶ Wx çš„ç»“æœæ˜¯1, y è¿˜å°†æ˜¯1, ä¸è¿‡ Wx ä¸º-1çš„æ—¶å€™, y ä¸å†æ˜¯-1, è€Œä¼šæ˜¯0.

ä½ ç”šè‡³å¯ä»¥åˆ›é€ è‡ªå·±çš„æ¿€åŠ±å‡½æ•°æ¥å¤„ç†è‡ªå·±çš„é—®é¢˜, ä¸è¿‡è¦ç¡®ä¿çš„æ˜¯è¿™äº›æ¿€åŠ±å‡½æ•°å¿…é¡»æ˜¯å¯ä»¥å¾®åˆ†çš„, å› ä¸ºåœ¨ backpropagation è¯¯å·®åå‘ä¼ é€’çš„æ—¶å€™, åªæœ‰è¿™äº›å¯å¾®åˆ†çš„æ¿€åŠ±å‡½æ•°æ‰èƒ½æŠŠè¯¯å·®ä¼ é€’å›å».

### å¸¸ç”¨é€‰æ‹©

![] (image/tf16.png)

æƒ³è¦æ°å½“ä½¿ç”¨è¿™äº›æ¿€åŠ±å‡½æ•°, è¿˜æ˜¯æœ‰çªé—¨çš„. æ¯”å¦‚å½“ä½ çš„ç¥ç»ç½‘ç»œå±‚åªæœ‰ä¸¤ä¸‰å±‚, ä¸æ˜¯å¾ˆå¤šçš„æ—¶å€™, å¯¹äºéšè—å±‚, ä½¿ç”¨ä»»æ„çš„æ¿€åŠ±å‡½æ•°, éšä¾¿æ°å¼¯æ˜¯å¯ä»¥çš„, ä¸ä¼šæœ‰ç‰¹åˆ«å¤§çš„å½±å“. ä¸è¿‡, å½“ä½ ä½¿ç”¨ç‰¹åˆ«å¤šå±‚çš„ç¥ç»ç½‘ç»œ, åœ¨æ°å¼¯çš„æ—¶å€™, ä¸‡ä¸‡ä¸å¾—éšæ„é€‰æ‹©åˆ©å™¨. å› ä¸ºè¿™ä¼šæ¶‰åŠåˆ°æ¢¯åº¦çˆ†ç‚¸, æ¢¯åº¦æ¶ˆå¤±çš„é—®é¢˜. .

æœ€åæˆ‘ä»¬è¯´è¯´, åœ¨å…·ä½“çš„ä¾‹å­ä¸­, æˆ‘ä»¬é»˜è®¤é¦–é€‰çš„æ¿€åŠ±å‡½æ•°æ˜¯å“ªäº›. åœ¨å°‘é‡å±‚ç»“æ„ä¸­, æˆ‘ä»¬å¯ä»¥å°è¯•å¾ˆå¤šç§ä¸åŒçš„æ¿€åŠ±å‡½æ•°. åœ¨å·ç§¯ç¥ç»ç½‘ç»œ Convolutional neural networks çš„å·ç§¯å±‚ä¸­, æ¨èçš„æ¿€åŠ±å‡½æ•°æ˜¯ relu. åœ¨å¾ªç¯ç¥ç»ç½‘ç»œä¸­ recurrent neural networks, æ¨èçš„æ˜¯ tanh æˆ–è€…æ˜¯ relu (è¿™ä¸ªå…·ä½“æ€ä¹ˆé€‰, æˆ‘ä¼šåœ¨ä»¥å å¾ªç¯ç¥ç»ç½‘ç»œçš„ä»‹ç»ä¸­åœ¨è¯¦ç»†è®²è§£).